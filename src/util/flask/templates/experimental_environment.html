{% extends 'base.html' %}

{% block title %}Experimentierumgebung{% endblock %}

{% block content %}
<style>
    /* Main content styling */
    #main-content {
        height: 100vh;
        overflow-y: auto; /* Enable scrolling in the main content */
        padding: 20px;
        box-sizing: border-box;
    }

    button {
        margin-top: 10px;
    }

    /* Ensure form inputs and selects fit the content area */
    form input, form select {
        width: 100%;
        max-width: 300px;
        margin-bottom: 10px;
    }
    .item-container {
        border: 1px solid #ccc;
        padding: 10px;
        margin-bottom: 10px;
    }

    .remove-btn {
        background-color: red;
        color: white;
        border: none;
        padding: 5px 10px;
        cursor: pointer;
        margin-top: 10px; /* Space between the last input and the button */
        display: block; /* Makes the button appear directly below the inputs */
        width: 10%; /* Full width for better UX */
        text-align: center;
    }
</style>

    <h1>Generate Simulation Configuration</h1>

    <form action="{{ url_for('experimental_environment') }}" method="POST" enctype="multipart/form-data" id="experimentForm">

        <!-- Model Name Section -->
        <h3>Model Configuration</h3>
        <label for="model_name">Model Name:</label>
        <input type="text" id="model_name" name="model_name" placeholder="Model1" required><br><br>

        <label for="scenario_name">Scenario Name:</label>
        <input type="text" id="scenario_name" name="scenario_name" placeholder="Scenario1" required><br><br>

        <!-- Source Section -->
        <h3>Source Configuration</h3>
        <div id="source-container"></div>
        <button type="button" id="add-source-btn">Add Source</button><br><br>

        <!-- Server Section -->
        <h3>Server Configuration</h3>
        <div id="server-container"></div>
        <button type="button" id="add-server-btn">Add Server</button><br><br>

        <!-- Sink Section -->
        <h3>Sink Configuration</h3>
        <div id="sink-container"></div>
        <button type="button" id="add-sink-btn">Add Sink</button><br><br>

        <input type="submit" value="Generate Configuration">
    </form>
<script>
    let componentCounts = {
        source: 0,
        server: 0,
        sink: 0,
    };

    let connections = [];

    // General function to add a new component
    function addComponent(type) {
        componentCounts[type]++;
        const container = document.getElementById(`${type}-container`);
        const count = componentCounts[type];

        let componentHtml = `
            <div id="${type}-${count}" class="item-container">
            <h4>${capitalize(type)} ${count}</h4>`;


        // Add fields common to all components
        componentHtml += `
            <label for="${type}_name_${count}">${capitalize(type)} Name:</label>
            <input type="text" id="${type}_name_${count}" name="${type}_name_${count}" required><br><br>`;

        if (type === 'source') {
            componentHtml += `
                <label for="dist_type_${count}">Creation Time Distribution Type:</label>
                <select id="dist_type_${count}" name="dist_type_${count}" onchange="updateDistributionParams(${count})">
                    <option value="">Select Distribution</option>
                    <option value="triangular">Triangular</option>
                    <option value="uniform">Uniform</option>
                    <option value="expovariate">Exponential</option>
                    <option value="normalvariate">Normal</option>
                </select><br><br>

                <!-- Container for distribution-specific parameters -->
                <div id="dist_params_${count}" class="dist-params-container"></div>


                <label for="arrival_table_${count}">Upload Arrival Table (CSV):</label>
                <input type="file" id="arrival_table_${count}" name="arrival_table_file_${count}" accept=".csv"><br><br>`;
        }
        // Fields specific to 'server' component
        if (type === 'server') {
            componentHtml += `
                <label for="dist_type_${count}">Processing Time Distribution Type:</label>
                <select id="dist_type_${count}" name="dist_type_${count}" onchange="updateDistributionParams(${count})">
                    <option value="">Select Distribution</option>
                    <option value="triangular">Triangular</option>
                    <option value="uniform">Uniform</option>
                    <option value="expovariate">Exponential</option>
                    <option value="normalvariate">Normal</option>
                </select><br><br>

                <!-- Container for distribution-specific parameters -->
                <div id="dist_params_${count}" class="dist-params-container"></div>

                <label for="queue_order_${count}">Queue Order:</label>
                <select id="queue_order_${count}" name="queue_order_${count}">
                    <option value="FIFO">FIFO</option>
                    <option value="LIFO">LIFO</option>
                </select><br><br>

                <label for="time_between_machine_breakdown_${count}">Time Between Machine Breakdown (optional):</label>
                <input type="number" id="time_between_machine_breakdown_${count}" name="time_between_machine_breakdown_${count}" step="0.01" placeholder="Optional" oninput="toggleBreakdownDuration(${count})"><br><br>

                <!-- Hidden by default, will appear when time_between_machine_breakdown is filled -->
                <div id="breakdown_duration_container_${count}" style="display: none;">
                    <label for="machine_breakdown_duration_${count}">Duration of Machine Breakdown:</label>
                    <input type="number" id="machine_breakdown_duration_${count}" name="machine_breakdown_duration_${count}" step="0.01" placeholder="Optional"><br><br>
                </div>`;
        }

        if (type === 'sink') {
            componentHtml += `
                <label for="addon_process_trigger_${count}">Addon Process Trigger (Optional):</label>
                <input type="text" id="addon_process_trigger_${count}" name="addon_process_trigger_${count}" placeholder="Addon Process Trigger"><br><br>`;
        }

        // Add a dropdown for selecting the target component for connections, only for 'source' and 'server'
        if (type === 'source' || type === 'server') {
            componentHtml += `
                <div id="connection_fields_${type}_${count}">
                    <label for="${type}_connection_${count}_1">Connect to:</label>
                    <select id="${type}_connection_${count}_1" name="${type}_connection_${count}_1" onchange="addConnectionDropdown('${type}', ${count}, 1, '${type}-${count}')">
                        <option value="">Select Target Component</option>
                    </select><br><br>
                </div>`;
        }

        componentHtml += `
            <button type="button" class="remove-btn">Delete ${capitalize(type)}</button>
        </div>`;

        container.insertAdjacentHTML('beforeend', componentHtml);

        console.log(`New component added: ${type}-${count}`);
        console.log(`Expected select ID: ${type}_connection_${count}`);

        // Use requestAnimationFrame to ensure the DOM is updated before populating the dropdown
        requestAnimationFrame(() => {
            if (type === 'source' || type === 'server') {
                updateConnectionOptions(`${type}_connection_${count}_1`, `${type}-${count}`);
            }
            // Update all dropdowns to include the new component
            updateConnectionOptions();
        });
    }

    // Function to handle dynamically adding new dropdowns for connections
    function addConnectionDropdown(type, count, dropdownNumber, componentToExclude) {
        const currentDropdown = document.getElementById(`${type}_connection_${count}_${dropdownNumber}`);
        const selectedValue = currentDropdown.value;

        // Only add a new dropdown if a selection has been made
        if (selectedValue !== "") {
            const container = document.getElementById(`connection_fields_${type}_${count}`);
            const nextDropdownNumber = dropdownNumber + 1;

            // Check if the next dropdown already exists; if not, create it
            if (!document.getElementById(`${type}_connection_${count}_${nextDropdownNumber}`)) {
                let newDropdownHtml = `
                    <label for="${type}_connection_${count}_${nextDropdownNumber}">Connect to:</label>
                    <select id="${type}_connection_${count}_${nextDropdownNumber}" name="${type}_connection_${count}_${nextDropdownNumber}" onchange="addConnectionDropdown('${type}', ${count}, ${nextDropdownNumber}, '${type}-${count}')">
                        <option value="">Select Target Component</option>
                    </select><br><br>`;

                container.insertAdjacentHTML('beforeend', newDropdownHtml);

                // Update only the newly added dropdown, exclude the current component and already connected components
                updateConnectionOptions(`${type}_connection_${count}_${nextDropdownNumber}`, componentToExclude, getCurrentConnections(type, count));
            }
        }

        // Update all dropdowns in this component to remove the selected value as an option
        updateComponentDropdowns(type, count, componentToExclude);
    }

    function updateComponentDropdowns(type, count, componentToExclude) {
        const connectedComponents = getCurrentConnections(type, count);
        let i = 1;
        let dropdown;
        while (dropdown = document.getElementById(`${type}_connection_${count}_${i}`)) {
            updateConnectionOptions(dropdown.id, componentToExclude, connectedComponents);
            i++;
        }
    }

    function updateConnectionOptions(dropdownIdToUpdate = null, componentToExclude = null, connectedComponents = []) {
        const sources = document.querySelectorAll('.item-container[id^="source"]');
        const servers = document.querySelectorAll('.item-container[id^="server"]');
        const sinks = document.querySelectorAll('.item-container[id^="sink"]');

        const allTargetComponents = [...servers, ...sinks];
        const allComponentsForServersAndSinks = [...sources, ...servers, ...sinks];

        function updateDropdown(dropdown) {
            if (!dropdown) return;

            const previousSelection = dropdown.value;
            dropdown.innerHTML = '<option value="">Select Target Component</option>';

            allTargetComponents.forEach((targetComponent) => {
                const targetType = targetComponent.id.split('-')[0];
                const targetCount = targetComponent.id.split('-')[1];
                const targetId = `${targetType}-${targetCount}`;

                if (targetId !== componentToExclude && !connectedComponents.includes(targetId)) {
                    dropdown.innerHTML += `<option value="${targetId}">${capitalize(targetType)} ${targetCount}</option>`;
                }
            });

            if (previousSelection && !connectedComponents.includes(previousSelection)) {
                dropdown.value = previousSelection;
            }
        }

        if (dropdownIdToUpdate) {
            updateDropdown(document.getElementById(dropdownIdToUpdate));
        } else {
            allComponentsForServersAndSinks.forEach((component) => {
                const [type, count] = component.id.split('-');
                const connectionFields = document.querySelectorAll(`#connection_fields_${type}_${count} select`);
                connectionFields.forEach(updateDropdown);
            });
        }
    }

    // Helper function to get all current connections for a component
    function getCurrentConnections(type, count) {
        const connections = [];
        let i = 1;
        let dropdown;
        while (dropdown = document.getElementById(`${type}_connection_${count}_${i}`)) {
            if (dropdown.value) {
                connections.push(dropdown.value);
            }
            i++;
        }
        return connections;
    }

    // Function to dynamically add connection-specific fields
    function addConnectionFields(type, count, connections) {
        const container = document.getElementById(`connections_params_${type}_${count}`);
        container.innerHTML = ''; // Clear existing fields

        connections.forEach((connection) => {
            const connectionHtml = `
                <label for="connection_param_${connection.target}_${count}">Parameter for Connection to ${connection.target}:</label>
                <input type="text" id="connection_param_${connection.target}_${count}" name="connection_param_${connection.target}_${count}" placeholder="Enter value"><br><br>`;
            container.insertAdjacentHTML('beforeend', connectionHtml);
        });
    }

    // Function to toggle the visibility of "Machine Breakdown Duration" based on input in "Time Between Machine Breakdown"
    function toggleBreakdownDuration(count) {
        const timeBetweenBreakdown = document.getElementById(`time_between_machine_breakdown_${count}`).value;
        const breakdownDurationContainer = document.getElementById(`breakdown_duration_container_${count}`);

        if (timeBetweenBreakdown) {
            // Show the breakdown duration input if time between breakdown is filled
            breakdownDurationContainer.style.display = 'block';
        } else {
            // Hide the breakdown duration input if time between breakdown is not filled
            breakdownDurationContainer.style.display = 'none';
        }
    }

    // Function to update the distribution-specific parameters based on the selection
    function updateDistributionParams(count) {
        const distType = document.getElementById(`dist_type_${count}`).value;
        const distParamsContainer = document.getElementById(`dist_params_${count}`);
        distParamsContainer.innerHTML = ''; // Clear previous inputs

        let paramsHtml = '';

        // Add the correct inputs based on the selected distribution
        if (distType === 'triangular') {
            paramsHtml = `
                <label for="low_${count}">Low:</label>
                <input type="number" id="low_${count}" name="low_${count}" step="0.01" min="0" required><br><br>

                <label for="mode_${count}">Mode:</label>
                <input type="number" id="mode_${count}" name="mode_${count}" step="0.01" required><br><br>

                <label for="high_${count}">High:</label>
                <input type="number" id="high_${count}" name="high_${count}" step="0.01" min="0" required><br><br>
            `;
        } else if (distType === 'uniform') {
            paramsHtml = `
                <label for="low_${count}">Low:</label>
                <input type="number" id="low_${count}" name="low_${count}" step="0.01" min="0" required><br><br>

                <label for="high_${count}">High:</label>
                <input type="number" id="high_${count}" name="high_${count}" step="0.01" min="0" required><br><br>
            `;
        } else if (distType === 'expovariate') {
            paramsHtml = `
                <label for="lambda_${count}">Lambda (Rate):</label>
                <input type="number" id="lambda_${count}" name="lambda_${count}" step="0.01" min="0" required><br><br>
            `;
        } else if (distType === 'normalvariate') {
            paramsHtml = `
                <label for="mu_${count}">Mean (μ):</label>
                <input type="number" id="mu_${count}" name="mu_${count}" step="0.01" required><br><br>

                <label for="sigma_${count}">Standard Deviation (σ):</label>
                <input type="number" id="sigma_${count}" name="sigma_${count}" step="0.01" required><br><br>
            `;
        }

    // Insert the parameters into the container
    distParamsContainer.innerHTML = paramsHtml;


    }

    // Event listeners for each button
    document.getElementById('add-source-btn').addEventListener('click', function() {
        addComponent('source');
    });

    document.getElementById('add-server-btn').addEventListener('click', function() {
        addComponent('server');
    });

    document.getElementById('add-sink-btn').addEventListener('click', function() {
        addComponent('sink');
    });

    // Function to remove the parent container of the clicked delete button
    function removeItem(event) {
        const itemContainer = event.target.closest('.item-container');
        const componentId = itemContainer.id;

        // Remove any connections involving this component
        connections = connections.filter(conn => conn.source !== componentId && conn.target !== componentId);
        console.log("Updated connections after deletion:", connections);

        itemContainer.remove();
        updateConnectionOptions();
    }

    // Event delegation to handle the removal of dynamically added elements
    document.addEventListener('click', function(event) {
        if (event.target.classList.contains('remove-btn')) {
            removeItem(event);
        }
    });

    // Function to handle CSV file upload
    function uploadCSV(event, count) {
        const fileInput = event.target;
        const file = fileInput.files[0];

        if (file) {
            const fileExtension = file.name.split('.').pop().toLowerCase();
            const fileType = file.type;

            // Check if the file has a CSV extension and correct MIME type
            if (fileExtension === 'csv' && fileType === 'text/csv') {
                const reader = new FileReader();

                reader.onload = function(e) {
                    // The file content is available in e.target.result
                    console.log(`File content for Source ${count}:`, e.target.result);

                    // You can process the CSV file data here, or pass it to the server
                };

                reader.readAsText(file);
            } else {
                alert("Please upload a valid CSV file.");
                fileInput.value = ""; // Clear the invalid file input
            }
        }
    }

    // Helper function to capitalize the first letter of a string
    function capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
</script>



{% endblock %}
