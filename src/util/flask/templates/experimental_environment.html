{% extends 'base.html' %}

{% block title %}Experimentierumgebung{% endblock %}

{% block content %}
<style>
    /* Main content styling */
    #main-content {
        height: 100vh;
        overflow-y: auto; /* Enable scrolling in the main content */
        padding: 20px;
        box-sizing: border-box;
    }

    button {
        margin-top: 10px;
    }

    /* Ensure form inputs and selects fit the content area */
    form input, form select {
        width: 100%;
        max-width: 300px;
        margin-bottom: 10px;
    }
    .item-container {
        border: 1px solid #ccc;
        padding: 10px;
        margin-bottom: 10px;
    }

    .remove-btn {
        background-color: red;
        color: white;
        border: none;
        padding: 5px 10px;
        cursor: pointer;
        margin-top: 10px; /* Space between the last input and the button */
        display: block; /* Makes the button appear directly below the inputs */
        width: 10%; /* Full width for better UX */
        text-align: center;
    }
</style>

    <h1>Generate Simulation Configuration</h1>

    <form action="{{ url_for('experimental_environment') }}" method="POST" enctype="multipart/form-data" id="experimentForm">

        <!-- Model Name Section -->
        <h3>Model Configuration</h3>
        <label for="model_name">Model Name:</label>
        <input type="text" id="model_name" name="model_name" placeholder="Model1" required><br><br>

        <label for="scenario_name">Scenario Name:</label>
        <input type="text" id="scenario_name" name="scenario_name" placeholder="Scenario1" required><br><br>

        <!-- Source Section -->
        <h3>Source Configuration</h3>
        <div id="source-container"></div>
        <button type="button" id="add-source-btn">Add Source</button><br><br>

        <!-- Server Section -->
        <h3>Server Configuration</h3>
        <div id="server-container"></div>
        <button type="button" id="add-server-btn">Add Server</button><br><br>

        <!-- Sink Section -->
        <h3>Sink Configuration</h3>
        <div id="sink-container"></div>
        <button type="button" id="add-sink-btn">Add Sink</button><br><br>

        <input type="submit" value="Generate Configuration">
    </form>
<script>
    let componentCounts = {
        source: 0,
        server: 0,
        sink: 0,
    };

    let connections = [];

    // General function to add a new component
function addComponent(type) {
    componentCounts[type]++;
    const container = document.getElementById(`${type}-container`);
    const count = componentCounts[type];
    const uniqueId = `${type}_${count}`;

    let componentHtml = `
        <div id="${uniqueId}" class="item-container">
        <h4>${capitalize(type)} ${count}</h4>`;

    // Add fields common to all components
    componentHtml += `
        <label for="name_${uniqueId}">${capitalize(type)} Name:</label>
        <input type="text" id="name_${uniqueId}" name="name_${uniqueId}" required><br><br>`;

    if (type === 'source') {
        componentHtml += `
            <label for="dist_type_${uniqueId}">Creation Time Distribution Type:</label>
            <select id="dist_type_${uniqueId}" name="dist_type_${uniqueId}" onchange="updateDistributionParams('${uniqueId}')">
                <option value="">Select Distribution</option>
                <option value="triangular">Triangular</option>
                <option value="uniform">Uniform</option>
                <option value="expovariate">Exponential</option>
                <option value="normalvariate">Normal</option>
            </select><br><br>

            <!-- Container for distribution-specific parameters -->
            <div id="dist_params_${uniqueId}" class="dist-params-container"></div>

            <label for="arrival_table_${uniqueId}">Upload Arrival Table (CSV):</label>
            <input type="file" id="arrival_table_${uniqueId}" name="arrival_table_file_${uniqueId}" accept=".csv"><br><br>`;
    }
    // Fields specific to 'server' component
    if (type === 'server') {
        componentHtml += `
            <label for="dist_type_${uniqueId}">Processing Time Distribution Type:</label>
            <select id="dist_type_${uniqueId}" name="dist_type_${uniqueId}" onchange="updateDistributionParams('${uniqueId}')">
                <option value="">Select Distribution</option>
                <option value="triangular">Triangular</option>
                <option value="uniform">Uniform</option>
                <option value="expovariate">Exponential</option>
                <option value="normalvariate">Normal</option>
            </select><br><br>

            <!-- Container for distribution-specific parameters -->
            <div id="dist_params_${uniqueId}" class="dist-params-container"></div>

            <label for="queue_order_${uniqueId}">Queue Order:</label>
            <select id="queue_order_${uniqueId}" name="queue_order_${uniqueId}">
                <option value="FIFO">FIFO</option>
                <option value="LIFO">LIFO</option>
            </select><br><br>

            <label for="time_between_machine_breakdown_${uniqueId}">Time Between Machine Breakdown (optional):</label>
            <input type="number" id="time_between_machine_breakdown_${uniqueId}" name="time_between_machine_breakdown_${uniqueId}" step="0.01" placeholder="Optional" oninput="toggleBreakdownDuration('${uniqueId}')"><br><br>

            <!-- Hidden by default, will appear when time_between_machine_breakdown is filled -->
            <div id="breakdown_duration_container_${uniqueId}" style="display: none;">
                <label for="machine_breakdown_duration_${uniqueId}">Duration of Machine Breakdown:</label>
                <input type="number" id="machine_breakdown_duration_${uniqueId}" name="machine_breakdown_duration_${uniqueId}" step="0.01" placeholder="Optional"><br><br>
            </div>`;
    }

    if (type === 'sink') {
        componentHtml += `
            <label for="addon_process_trigger_${uniqueId}">Addon Process Trigger (Optional):</label>
            <input type="text" id="addon_process_trigger_${uniqueId}" name="addon_process_trigger_${uniqueId}" placeholder="Addon Process Trigger"><br><br>`;
    }

    // Add a dropdown for selecting the target component for connections, only for 'source' and 'server'
    if (type === 'source' || type === 'server') {
        componentHtml += `
            <div id="connection_fields_${uniqueId}">
                <label for="connection_${uniqueId}_1">Connect to:</label>
                <select id="connection_${uniqueId}_1" name="connection_${uniqueId}_1" onchange="addConnectionDropdown('${uniqueId}', 1, '${uniqueId}')">
                    <option value="">Select Target Component</option>
                </select><br><br>

                <!-- Container for connection-specific parameters -->
                <div id="connection_params_${uniqueId}_1"></div>
            </div>`;
    }

    componentHtml += `
        <button type="button" class="remove-btn">Delete ${capitalize(type)}</button>
    </div>`;

    container.insertAdjacentHTML('beforeend', componentHtml);

    console.log(`New component added: ${uniqueId}`);
    console.log(`Expected select ID: connection_${uniqueId}_1`);

    // Use requestAnimationFrame to ensure the DOM is updated before populating the dropdown
    requestAnimationFrame(() => {
        if (type === 'source' || type === 'server') {
            updateConnectionOptions(`connection_${uniqueId}_1`, uniqueId);
        }
        // Update all dropdowns to include the new component
        updateConnectionOptions();
    });
}

// Function to handle dynamically adding new dropdowns for connections
function addConnectionDropdown(uniqueId, dropdownNumber, componentToExclude) {
    const currentDropdown = document.getElementById(`connection_${uniqueId}_${dropdownNumber}`);
    const selectedValue = currentDropdown.value;

    // Remove existing connection parameters for this dropdown number
    const paramsContainer = document.getElementById(`connection_params_${uniqueId}_${dropdownNumber}`);
    if (paramsContainer) {
        paramsContainer.remove();
    }

    // Only add a new dropdown if a selection has been made
    if (selectedValue !== "") {
        const container = document.getElementById(`connection_fields_${uniqueId}`);
        const nextDropdownNumber = dropdownNumber + 1;

        // Add fields for Probability and Process Duration
        let connectionParamsHtml = `
            <div id="connection_params_${uniqueId}_${dropdownNumber}">
                <label for="probability_${uniqueId}_${dropdownNumber}">Probability (1-100):</label>
                <input type="number" id="probability_${uniqueId}_${dropdownNumber}" name="probability_${uniqueId}_${dropdownNumber}" min="1" max="100" step="0.01" placeholder="Optional"><br><br>

                <label for="process_duration_${uniqueId}_${dropdownNumber}">Process Duration (Positive Float):</label>
                <input type="number" id="process_duration_${uniqueId}_${dropdownNumber}" name="process_duration_${uniqueId}_${dropdownNumber}" min="0" step="0.01" placeholder="Optional"><br><br>
            </div>`;

        container.insertAdjacentHTML('beforeend', connectionParamsHtml);

        // Check if the next dropdown already exists; if not, create it
        if (!document.getElementById(`connection_${uniqueId}_${nextDropdownNumber}`)) {
            let newDropdownHtml = `
                <label for="connection_${uniqueId}_${nextDropdownNumber}">Connect to:</label>
                <select id="connection_${uniqueId}_${nextDropdownNumber}" name="connection_${uniqueId}_${nextDropdownNumber}" onchange="addConnectionDropdown('${uniqueId}', ${nextDropdownNumber}, '${uniqueId}')">
                    <option value="">Select Target Component</option>
                </select><br><br>

                <!-- Container for connection-specific parameters -->
                <div id="connection_params_${uniqueId}_${nextDropdownNumber}"></div>`;

            container.insertAdjacentHTML('beforeend', newDropdownHtml);

            // Update only the newly added dropdown
            updateConnectionOptions(`connection_${uniqueId}_${nextDropdownNumber}`, uniqueId, getCurrentConnections(uniqueId));
        }
    }

    // Update all dropdowns in this component to remove the selected value as an option
    updateComponentDropdowns(uniqueId, uniqueId);
}


function updateComponentDropdowns(type, count, componentToExclude) {
    const connectedComponents = getCurrentConnections(type, count);
    let i = 1;
    let dropdown;
    while ((dropdown = document.getElementById(`${type}_connection_${count}_${i}`))) {
        updateConnectionOptions(dropdown.id, componentToExclude, connectedComponents);
        i++;
    }
}

function updateConnectionOptions(dropdownIdToUpdate = null, componentToExclude = null, connectedComponents = []) {
    const sources = document.querySelectorAll('.item-container[id^="source_"]');
    const servers = document.querySelectorAll('.item-container[id^="server_"]');
    const sinks = document.querySelectorAll('.item-container[id^="sink_"]');

    const allTargetComponents = [...servers, ...sinks];
    const allComponentsForServersAndSinks = [...sources, ...servers, ...sinks];

    function updateDropdown(dropdown, componentToExclude, connectedComponents) {
        if (!dropdown) return;

        const previousSelection = dropdown.value;
        dropdown.innerHTML = '<option value="">Select Target Component</option>';

        allTargetComponents.forEach((targetComponent) => {
            const targetId = targetComponent.id;

            // Extract type and count for display purposes
            const [targetType, targetCount] = targetId.split('_');

            // Include the previous selection even if it's in connectedComponents
            if (targetId !== componentToExclude && (!connectedComponents.includes(targetId) || targetId === previousSelection)) {
                dropdown.innerHTML += `<option value="${targetId}">${capitalize(targetType)} ${targetCount}</option>`;
            }
        });

        // Set the dropdown's value back to the previous selection if it still exists
        if (previousSelection && dropdown.querySelector(`option[value="${previousSelection}"]`)) {
            dropdown.value = previousSelection;
        } else {
            // If the previous selection is no longer valid, remove associated parameters
            const paramsContainerId = dropdown.id.replace('connection', 'connection_params');
            const paramsContainer = document.getElementById(paramsContainerId);
            if (paramsContainer) {
                paramsContainer.remove();
            }
        }
    }

    if (dropdownIdToUpdate) {
        const dropdown = document.getElementById(dropdownIdToUpdate);
        updateDropdown(dropdown, componentToExclude, connectedComponents);
    } else {
        allComponentsForServersAndSinks.forEach((component) => {
            const uniqueId = component.id;
            const componentToExclude = uniqueId;
            const connectedComponents = getCurrentConnections(uniqueId);
            const connectionFields = document.querySelectorAll(`#connection_fields_${uniqueId} select`);
            connectionFields.forEach((dropdown) => {
                updateDropdown(dropdown, componentToExclude, connectedComponents);
            });
        });
    }
}


// Helper function to get all current connections for a component
function getCurrentConnections(uniqueId) {
    const connections = [];
    let i = 1;
    let dropdown;
    while ((dropdown = document.getElementById(`connection_${uniqueId}_${i}`))) {
        if (dropdown.value) {
            connections.push(dropdown.value);
        }
        i++;
    }
    return connections;
}



    // Function to toggle the visibility of "Machine Breakdown Duration" based on input in "Time Between Machine Breakdown"
    function toggleBreakdownDuration(count) {
        const timeBetweenBreakdown = document.getElementById(`time_between_machine_breakdown_${count}`).value;
        const breakdownDurationContainer = document.getElementById(`breakdown_duration_container_${count}`);

        if (timeBetweenBreakdown) {
            // Show the breakdown duration input if time between breakdown is filled
            breakdownDurationContainer.style.display = 'block';
        } else {
            // Hide the breakdown duration input if time between breakdown is not filled
            breakdownDurationContainer.style.display = 'none';
        }
    }

    // Function to update the distribution-specific parameters based on the selection
    function updateDistributionParams(uniqueId) {
        const distType = document.getElementById(`dist_type_${uniqueId}`).value;
        const distParamsContainer = document.getElementById(`dist_params_${uniqueId}`);
        distParamsContainer.innerHTML = ''; // Clear previous inputs

        let paramsHtml = '';

        // Add the correct inputs based on the selected distribution
        if (distType === 'triangular') {
            paramsHtml = `
                <label for="low_${uniqueId}">Low:</label>
                <input type="number" id="low_${uniqueId}" name="low_${uniqueId}" step="0.01" min="0" required><br><br>

                <label for="mode_${uniqueId}">Mode:</label>
                <input type="number" id="mode_${uniqueId}" name="mode_${uniqueId}" step="0.01" required><br><br>

                <label for="high_${uniqueId}">High:</label>
                <input type="number" id="high_${uniqueId}" name="high_${uniqueId}" step="0.01" min="0" required><br><br>
            `;
        } else if (distType === 'uniform') {
            paramsHtml = `
                <label for="low_${uniqueId}">Low:</label>
                <input type="number" id="low_${uniqueId}" name="low_${uniqueId}" step="0.01" min="0" required><br><br>

                <label for="high_${uniqueId}">High:</label>
                <input type="number" id="high_${uniqueId}" name="high_${uniqueId}" step="0.01" min="0" required><br><br>
            `;
        } else if (distType === 'expovariate') {
            paramsHtml = `
                <label for="lambda_${uniqueId}">Lambda (Rate):</label>
                <input type="number" id="lambda_${uniqueId}" name="lambda_${uniqueId}" step="0.01" min="0" required><br><br>
            `;
        } else if (distType === 'normalvariate') {
            paramsHtml = `
                <label for="mu_${uniqueId}">Mean (μ):</label>
                <input type="number" id="mu_${uniqueId}" name="mu_${uniqueId}" step="0.01" required><br><br>

                <label for="sigma_${uniqueId}">Standard Deviation (σ):</label>
                <input type="number" id="sigma_${uniqueId}" name="sigma_${uniqueId}" step="0.01" required><br><br>
            `;
        }

    // Insert the parameters into the container
    distParamsContainer.innerHTML = paramsHtml;


    }

    // Event listeners for each button
    document.getElementById('add-source-btn').addEventListener('click', function() {
        addComponent('source');
    });

    document.getElementById('add-server-btn').addEventListener('click', function() {
        addComponent('server');
    });

    document.getElementById('add-sink-btn').addEventListener('click', function() {
        addComponent('sink');
    });

    // Function to remove the parent container of the clicked delete button
    function removeItem(event) {
        const itemContainer = event.target.closest('.item-container');
        const componentId = itemContainer.id;

        // Remove any connections involving this component
        connections = connections.filter(conn => conn.source !== componentId && conn.target !== componentId);
        console.log("Updated connections after deletion:", connections);

        itemContainer.remove();
        updateConnectionOptions();
    }

    // Event delegation to handle the removal of dynamically added elements
    document.addEventListener('click', function(event) {
        if (event.target.classList.contains('remove-btn')) {
            removeItem(event);
        }
    });

    // Function to handle CSV file upload
    function uploadCSV(event, count) {
        const fileInput = event.target;
        const file = fileInput.files[0];

        if (file) {
            const fileExtension = file.name.split('.').pop().toLowerCase();
            const fileType = file.type;

            // Check if the file has a CSV extension and correct MIME type
            if (fileExtension === 'csv' && fileType === 'text/csv') {
                const reader = new FileReader();

                reader.onload = function(e) {
                    // The file content is available in e.target.result
                    console.log(`File content for Source ${count}:`, e.target.result);

                    // You can process the CSV file data here, or pass it to the server
                };

                reader.readAsText(file);
            } else {
                alert("Please upload a valid CSV file.");
                fileInput.value = ""; // Clear the invalid file input
            }
        }
    }

    // Helper function to capitalize the first letter of a string
    function capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
</script>



{% endblock %}
